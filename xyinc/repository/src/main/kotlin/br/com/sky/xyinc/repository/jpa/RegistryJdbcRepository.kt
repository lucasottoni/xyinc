package br.com.sky.xyinc.repository.jpa

import br.com.sky.xyinc.core.domain.FieldType
import br.com.sky.xyinc.core.domain.ModelDefinition
import br.com.sky.xyinc.repository.entity.RegistryEntity
import br.com.sky.xyinc.repository.entity.RegistryEntity.Companion.ID
import org.springframework.dao.EmptyResultDataAccessException
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.simple.SimpleJdbcInsert
import org.springframework.stereotype.Repository


@Repository
class RegistryJdbcRepository(private val jdbcTemplate: JdbcTemplate) {

    fun createTable(modelDefinition: ModelDefinition) {
        val sql = StringBuilder("CREATE TABLE ${modelDefinition.tableName} (")
        sql.append("$ID INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1)")
        modelDefinition.fields.forEach { field ->
            sql.append(", ").append(field.name.lowercase()).append(" ")
                .append(field.type.toDbType())
        }
        sql.append(");")

        jdbcTemplate.execute(sql.toString())
    }

    fun checkTable(modelDefinition: ModelDefinition): Boolean {
        val query =
            ("select count(*) "
                    + "from information_schema.tables "
                    + "where table_name = ?")
        val result = jdbcTemplate.queryForObject(query, Int::class.java, modelDefinition.tableName)
        return result == 1
    }

    fun findById(modelDefinition: ModelDefinition, id: Long): RegistryEntity? {
        val sql = "SELECT * FROM ${modelDefinition.tableName} WHERE $ID = ?"
        return try {
            val map = jdbcTemplate.queryForMap(sql, id)
            return toEntity(map)
        } catch (e: EmptyResultDataAccessException) {
            null
        }
    }

    fun findAll(modelDefinition: ModelDefinition): List<RegistryEntity> {
        val sql = "SELECT * FROM ${modelDefinition.tableName}"
        return jdbcTemplate.queryForList(sql).map { toEntity(it) }
    }

    fun insert(modelDefinition: ModelDefinition, values: Map<String, Any>): RegistryEntity {
        val insert = SimpleJdbcInsert(jdbcTemplate)
            .withTableName(modelDefinition.tableName)
            .usingColumns(*modelDefinition.fields.map { it.name }.toTypedArray())
            .usingGeneratedKeyColumns(ID)

        val key = insert.executeAndReturnKey(values).toLong()
        return findById(modelDefinition, key)!!
    }

    fun update(modelDefinition: ModelDefinition, id: Long, values: Map<String, Any?>): RegistryEntity {
        val sqlUpdateFields = modelDefinition.fields.joinToString(separator = ",") { field ->
            "${field.name} = ?"
        }
        val sqlArgs = modelDefinition.fields.map { field ->
            values[field.name]
        }

        val sql = "UPDATE ${modelDefinition.tableName} SET $sqlUpdateFields WHERE $ID = $id"

        jdbcTemplate.update(sql, sqlArgs)

        return findById(modelDefinition, id)!!
    }

    fun delete(modelDefinition: ModelDefinition, id: Long) {
        val sql = "DELETE FROM ${modelDefinition.tableName} WHERE $ID = $id"
        jdbcTemplate.update(sql, id)
    }

    fun countByDefinition(modelDefinition: ModelDefinition): Long {
        val sql = "SELECT count(*) FROM ${modelDefinition.tableName}"
        return jdbcTemplate.queryForObject(sql, Long::class.java) ?: 0
    }

    private val ModelDefinition.tableName: String
        get() {
            val sanitizedName = this.name.lowercase()
            return "tbl_$sanitizedName"
        }

    private fun FieldType.toDbType(): String {
        return when (this) {
            FieldType.INTEGER -> "INTEGER"
            FieldType.DECIMAL -> "DECIMAL(12,5)"
            FieldType.DOUBLE -> "DOUBLE"
            FieldType.TEXT -> "TEXT"
        }
    }

    private fun toEntity(map: Map<String, Any>) : RegistryEntity {
        return RegistryEntity(
            id = map[ID].toString().toLong(),
            values = map.filter { it.key != ID }
        )
    }
}