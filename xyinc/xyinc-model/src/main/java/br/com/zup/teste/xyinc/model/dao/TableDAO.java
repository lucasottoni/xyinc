package br.com.zup.teste.xyinc.model.dao;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.util.Assert;

import br.com.zup.teste.xyinc.model.entity.Model;
import br.com.zup.teste.xyinc.model.entity.ModelField;
import br.com.zup.teste.xyinc.model.enums.MessageKeyEnum;

/**
 * TableDAO
 * Performs database operations on tables created through a Model.
 *
 * @author lucasottoni
 *
 */
@Repository
public class TableDAO {

	@Autowired
	private JdbcTemplate jdbcTemplate;

	/**
	 * Given a model, creates a table on database for it.
	 *
	 * @param model - Metadata for the table.
	 */
	public void createTable(Model model) {
		Assert.notNull(model, MessageKeyEnum.ERROR_MODEL_NULL.toPropertyName());
		Assert.notNull(model.getName(), MessageKeyEnum.ERROR_NAME_NULL.toPropertyName());
		Assert.notNull(model.getFields(), MessageKeyEnum.ERROR_FIELDS_EMPTY.toPropertyName());
		Assert.notEmpty(model.getFields(), MessageKeyEnum.ERROR_FIELDS_EMPTY.toPropertyName());
		StringBuilder sql = new StringBuilder("CREATE TABLE ");
		sql.append(model.getName().toLowerCase());
		sql.append("(id INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) ");
		for (ModelField modelField : model.getFields()) {
			Assert.notNull(modelField, MessageKeyEnum.ERROR_MODEL_FIELD_NULL.toPropertyName());
			Assert.notNull(modelField.getName(), MessageKeyEnum.ERROR_NAME_NULL.toPropertyName());
			Assert.notNull(modelField.getType(), MessageKeyEnum.ERROR_TYPE_NULL.toPropertyName());
			sql.append(", ");
			sql.append(modelField.getName().toLowerCase());
			sql.append(" ");
			sql.append(modelField.getType().type());
		}
		sql.append(");");
		jdbcTemplate.update(sql.toString());
	}

	/**
	 * Inserts a model on a given table. Values should be inside ModelFields.
	 *
	 * @param model - Data to be inserted.
	 * @return Model - Inserted model with id.
	 */
	public synchronized Model insertIntoTable(Model model) {
		Assert.notNull(model, MessageKeyEnum.ERROR_MODEL_NULL.toPropertyName());
		Assert.notNull(model.getName(), MessageKeyEnum.ERROR_NAME_NULL.toPropertyName());
		Assert.notNull(model.getFields(), MessageKeyEnum.ERROR_FIELDS_EMPTY.toPropertyName());
		Assert.notEmpty(model.getFields(), MessageKeyEnum.ERROR_FIELDS_EMPTY.toPropertyName());
		StringBuilder sql = new StringBuilder("INSERT INTO ");
		sql.append(model.getName().toLowerCase());
		sql.append("(");
		StringBuilder sqlNames = new StringBuilder();
		StringBuilder sqlValues = new StringBuilder();
		Object[] args = new Object[model.getFields().size()];
		int i = 0;
		for (ModelField modelField : model.getFields()) {
			Assert.notNull(modelField, MessageKeyEnum.ERROR_MODEL_FIELD_NULL.toPropertyName());
			Assert.notNull(modelField.getName(), MessageKeyEnum.ERROR_NAME_NULL.toPropertyName());
			sqlNames.append(modelField.getName().toLowerCase());
			sqlNames.append(", ");
			sqlValues.append("?, ");
			args[i] = modelField.getValue();
			i++;
		}
		sql.append(sqlNames.substring(0, sqlNames.length() - 2));
		sql.append(") VALUES (");
		sql.append(sqlValues.substring(0, sqlValues.length() - 2));
		sql.append(");");
		jdbcTemplate.update(sql.toString(), args);
		model.setValue(jdbcTemplate.queryForObject("SELECT MAX(id) FROM " + model.getName(), Integer.class));
		return model;
	}

	/**
	 * Retrieves all records for a given table.
	 *
	 * @param model - Model that describes the table.
	 * @return List<Model> - a list with all records found for given table.
	 */
	public List<Model> selectAllFromTable(Model model) {
		Assert.notNull(model, MessageKeyEnum.ERROR_MODEL_NULL.toPropertyName());
		Assert.notNull(model.getName(), MessageKeyEnum.ERROR_NAME_NULL.toPropertyName());
		Assert.notNull(model.getFields(), MessageKeyEnum.ERROR_FIELDS_EMPTY.toPropertyName());
		Assert.notEmpty(model.getFields(), MessageKeyEnum.ERROR_FIELDS_EMPTY.toPropertyName());
		StringBuilder sql = generateSelect(model);
		List<Map<String, Object>> listMap = jdbcTemplate.queryForList(sql.toString());
		return processListMap(model, listMap);
	}

	/**
	 * Retrieves a record of a given table by its id.
	 *
	 * @param model - Model that describes the table.
	 * @param id - Integer with record's identifier.
	 * @return Model - a model with the record found, null if not found.
	 */
	public Model selectFromTable(Model model) {
		Assert.notNull(model, MessageKeyEnum.ERROR_MODEL_NULL.toPropertyName());
		Assert.notNull(model.getName(), MessageKeyEnum.ERROR_NAME_NULL.toPropertyName());
		Assert.notNull(model.getFields(), MessageKeyEnum.ERROR_FIELDS_EMPTY.toPropertyName());
		Assert.notEmpty(model.getFields(), MessageKeyEnum.ERROR_FIELDS_EMPTY.toPropertyName());
		Assert.notNull(model.getValue(), MessageKeyEnum.ERROR_ID_NULL.toPropertyName());
		StringBuilder sql = generateSelect(model);
		sql.append(" WHERE id = ?");
		List<Map<String, Object>> listMap = jdbcTemplate.queryForList(sql.toString(), model.getValue());
		List<Model> listModel = processListMap(model, listMap);
		if (listModel.isEmpty()) {
			return null;
		}
		return listModel.get(0);
	}

	/**
	 * Updates a record on a given table.
	 *
	 * @param model - Model to be updated. Only altered fields should be informed.
	 */
	public synchronized void updateTable(Model model) {
		Assert.notNull(model, MessageKeyEnum.ERROR_MODEL_NULL.toPropertyName());
		Assert.notNull(model.getName(), MessageKeyEnum.ERROR_NAME_NULL.toPropertyName());
		Assert.notNull(model.getFields(), MessageKeyEnum.ERROR_FIELDS_EMPTY.toPropertyName());
		Assert.notEmpty(model.getFields(), MessageKeyEnum.ERROR_FIELDS_EMPTY.toPropertyName());
		Assert.notNull(model.getValue(), MessageKeyEnum.ERROR_ID_NULL.toPropertyName());
		StringBuilder sql = new StringBuilder("UPDATE ");
		sql.append(model.getName().toLowerCase());
		sql.append(" SET ");
		StringBuilder sqlNames = new StringBuilder();
		Object[] args = new Object[model.getFields().size() + 1];
		int i = 0;
		for (ModelField modelField : model.getFields()) {
			Assert.notNull(modelField, MessageKeyEnum.ERROR_MODEL_FIELD_NULL.toPropertyName());
			Assert.notNull(modelField.getName(), MessageKeyEnum.ERROR_NAME_NULL.toPropertyName());
			Assert.notNull(modelField.getValue(), MessageKeyEnum.ERROR_VALUE_NULL.toPropertyName());
			sqlNames.append(modelField.getName().toLowerCase());
			sqlNames.append(" = ?, ");
			args[i] = modelField.getValue();
			i++;
		}
		args[i] = model.getValue();
		sql.append(sqlNames.substring(0, sqlNames.length() - 2));
		sql.append(" WHERE id = ?");
		jdbcTemplate.update(sql.toString(), args);
	}

	/**
	 * Removes a record from a table, given its id.
	 *
	 * @param tableName - The table name where the record should be removed.
	 * @param id - Id to be removed.
	 */
	public synchronized void deleteFromTable(String tableName, Integer id) {
		Assert.notNull(tableName, MessageKeyEnum.ERROR_NAME_NULL.toPropertyName());
		Assert.notNull(id, MessageKeyEnum.ERROR_ID_NULL.toPropertyName());
		StringBuilder sql = new StringBuilder("DELETE FROM ");
		sql.append(tableName.toLowerCase());
		sql.append(" WHERE id = ?");
		jdbcTemplate.update(sql.toString(), id);
	}

	/**
	 * Creates a StringBuilder with a complete SELECT statament, given a model.
	 *
	 * @param model - Model that should be represented on SELECT.
	 * @return StringBuilder - Contains the SQL SELECT statement.
	 */
	private StringBuilder generateSelect(Model model) {
		StringBuilder sql = new StringBuilder("SELECT id, ");
		StringBuilder sqlNames = new StringBuilder();
		for (ModelField modelField : model.getFields()) {
			Assert.notNull(modelField, MessageKeyEnum.ERROR_MODEL_FIELD_NULL.toPropertyName());
			Assert.notNull(modelField.getName(), MessageKeyEnum.ERROR_NAME_NULL.toPropertyName());
			sqlNames.append(modelField.getName().toLowerCase());
			sqlNames.append(", ");
		}
		sql.append(sqlNames.substring(0, sqlNames.length() - 2));
		sql.append(" FROM ");
		sql.append(model.getName().toLowerCase());
		return sql;
	}

	/**
	 * Given a list of maps, on which each map has pairs of properties and values,
	 * mounts a list of corresponding model.
	 *
	 * @param model - Base model to generate the list.
	 * @param listMap - List<Map<String, Object>> representing a list of records from given table.
	 * @return List<Model> - List of objects retrieved from database.
	 */
	private List<Model> processListMap(Model model, List<Map<String, Object>> listMap) {
		List<Model> listModel = new ArrayList<Model>();
		for (Map<String, Object> map : listMap) {
			Model newModel = new Model();
			newModel.setName(model.getName());
			newModel.setId(model.getId());
			newModel.setValue((Integer)map.get("id"));
			newModel.setFields(new ArrayList<ModelField>());
			for (ModelField modelField : model.getFields()) {
				ModelField newModelField = new ModelField();
				newModelField.setId(modelField.getId());
				newModelField.setName(modelField.getName());
				newModelField.setType(modelField.getType());
				newModelField.setValue(map.get(modelField.getName()));
				newModel.getFields().add(newModelField);
			}
			listModel.add(newModel);
		}
		return listModel;
	}
}
